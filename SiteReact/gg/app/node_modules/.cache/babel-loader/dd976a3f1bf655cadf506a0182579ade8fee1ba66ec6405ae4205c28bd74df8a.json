{"ast":null,"code":"import _slicedToArray from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _set from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/set.js\";\nimport _get from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nvar MaskedDynamic = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedDynamic, _Masked);\n  var _super = _createSuper(MaskedDynamic);\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  function MaskedDynamic(opts) {\n    var _this;\n    _classCallCheck(this, MaskedDynamic);\n    _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    _this.currentMask = null;\n    return _this;\n  }\n\n  /**\n    @override\n  */\n  _createClass(MaskedDynamic, [{\n    key: \"_update\",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"_update\", this).call(this, opts);\n      if ('mask' in opts) {\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return createMask(m);\n        }) : [];\n\n        // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n      }\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var details = this._applyDispatch(ch, flags);\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n      }\n      return details;\n    }\n  }, {\n    key: \"_applyDispatch\",\n    value: function _applyDispatch() {\n      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      var inputValue = this.rawInputValue;\n      var insertValue = flags.tail && flags._beforeTailState != null ?\n      // $FlowFixMe - tired to fight with type system\n      flags._beforeTailState._rawInputValue : inputValue;\n      var tailValue = inputValue.slice(insertValue.length);\n      var prevMask = this.currentMask;\n      var details = new ChangeDetails();\n      var prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n      // clone flags to prevent overwriting `_beforeTailState`\n      this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail);\n\n      // restore state after dispatch\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset();\n          if (insertValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            var d = this.currentMask.append(insertValue, {\n              raw: true\n            });\n            details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n          }\n          if (tailValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      var details = this._applyDispatch.apply(this, arguments);\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n      return details;\n    }\n\n    /**\n     @override\n    */\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var details = this._applyDispatch.apply(this, arguments);\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendEager());\n      }\n      return details;\n    }\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      var details = new ChangeDetails();\n      if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n      return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : _get(_getPrototypeOf(MaskedDynamic.prototype), \"appendTail\", this).call(this, tail));\n    }\n  }, {\n    key: \"currentMaskFlags\",\n    value: function currentMaskFlags(flags) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      return Object.assign({}, flags, {\n        _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"doDispatch\",\n    value: function doDispatch(appended) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      return this.dispatch(appended, this, flags, tail);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return _get(_getPrototypeOf(MaskedDynamic.prototype), \"doValidate\", this).call(this, flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _normalizePrepare = normalizePrepare(_get(_getPrototypeOf(MaskedDynamic.prototype), \"doPrepare\", this).call(this, str, flags)),\n        _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2),\n        s = _normalizePrepare2[0],\n        details = _normalizePrepare2[1];\n      if (this.currentMask) {\n        var currentDetails;\n        var _normalizePrepare3 = normalizePrepare(_get(_getPrototypeOf(MaskedDynamic.prototype), \"doPrepare\", this).call(this, s, this.currentMaskFlags(flags)));\n        var _normalizePrepare4 = _slicedToArray(_normalizePrepare3, 2);\n        s = _normalizePrepare4[0];\n        currentDetails = _normalizePrepare4[1];\n        details = details.aggregate(currentDetails);\n      }\n      return [s, details];\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this$currentMask;\n      (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n      this.compiledMasks.forEach(function (m) {\n        return m.reset();\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.value : '';\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"value\", value, this, true);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.unmaskedValue : '';\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.typedValue : '';\n    }\n\n    // probably typedValue should not be used with dynamic\n    ,\n    set: function set(value) {\n      var unmaskedValue = String(value);\n\n      // double check it\n      if (this.currentMask) {\n        this.currentMask.typedValue = value;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n      this.unmaskedValue = unmaskedValue;\n    }\n  }, {\n    key: \"displayValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.displayValue : '';\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      var _this$currentMask2;\n      return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      var _this$currentMask3;\n      return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var details = new ChangeDetails();\n      if (this.currentMask) {\n        var _this$currentMask6;\n        details.aggregate((_this$currentMask6 = this.currentMask).remove.apply(_this$currentMask6, arguments))\n        // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n      return details;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"state\",\n    get: function get() {\n      var _this$currentMask4;\n      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), \"state\", this), {\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(function (m) {\n          return m.state;\n        }),\n        currentMaskRef: this.currentMask,\n        currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n      });\n    },\n    set: function set(state) {\n      var compiledMasks = state.compiledMasks,\n        currentMaskRef = state.currentMaskRef,\n        currentMask = state.currentMask,\n        maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n      this.compiledMasks.forEach(function (m, mi) {\n        return m.state = compiledMasks[mi];\n      });\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"state\", maskedState, this, true);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var _this$currentMask7;\n      return this.currentMask ? (_this$currentMask7 = this.currentMask).extractInput.apply(_this$currentMask7, arguments) : '';\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this$currentMask8;\n      return this.currentMask ? (_this$currentMask8 = this.currentMask).extractTail.apply(_this$currentMask8, arguments) : _get(_getPrototypeOf(MaskedDynamic.prototype), \"extractTail\", this).apply(this, arguments);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"doCommit\", this).call(this);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos() {\n      var _this$currentMask9;\n      return this.currentMask ? (_this$currentMask9 = this.currentMask).nearestInputPos.apply(_this$currentMask9, arguments) : _get(_getPrototypeOf(MaskedDynamic.prototype), \"nearestInputPos\", this).apply(this, arguments);\n    }\n  }, {\n    key: \"overwrite\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), \"overwrite\", this);\n    },\n    set: function set(overwrite) {\n      console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }, {\n    key: \"eager\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.eager : _get(_getPrototypeOf(MaskedDynamic.prototype), \"eager\", this);\n    },\n    set: function set(eager) {\n      console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }, {\n    key: \"skipInvalid\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.skipInvalid : _get(_getPrototypeOf(MaskedDynamic.prototype), \"skipInvalid\", this);\n    },\n    set: function set(skipInvalid) {\n      if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n        console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n      }\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return Array.isArray(mask) && this.compiledMasks.every(function (m, mi) {\n        if (!mask[mi]) return;\n        var _mask$mi = mask[mi],\n          oldMask = _mask$mi.mask,\n          restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n        return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"typedValueEquals\",\n    value: function typedValueEquals(value) {\n      var _this$currentMask5;\n      return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n    }\n  }]);\n  return MaskedDynamic;\n}(Masked);\nMaskedDynamic.DEFAULTS = {\n  dispatch: function dispatch(appended, masked, flags, tail) {\n    if (!masked.compiledMasks.length) return;\n    var inputValue = masked.rawInputValue;\n\n    // simulate input\n    var inputs = masked.compiledMasks.map(function (m, index) {\n      var isCurrent = masked.currentMask === m;\n      var startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index: index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort(function (i1, i2) {\n      return i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions;\n    });\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","normalizePrepare","objectIncludes","ChangeDetails","createMask","Masked","IMask","_excluded","_excluded2","MaskedDynamic","opts","Object","assign","DEFAULTS","currentMask","compiledMasks","Array","isArray","mask","map","m","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","str","s","currentDetails","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","_this$currentMask2","Boolean","isComplete","_this$currentMask3","isFilled","remove","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","overwrite","console","warn","eager","skipInvalid","isInitialized","every","_mask$mi","oldMask","restOpts","maskEquals","_this$currentMask5","typedValueEquals","masked","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["C:/Users/admin/Desktop/Документы/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.dispatch(appended, this, flags, tail);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":";;;;;;;;AAAA,SAASA,CAAC,IAAIC,6BAA6B,QAAQ,0CAA0C;AAC7F,SAASC,SAAS,EAAEC,gBAAgB,EAAEC,cAAc,QAAQ,kBAAkB;AAC9E,OAAOC,aAAa,MAAM,2BAA2B;AACrD,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,MAAM,MAAM,WAAW;AAC9B,OAAOC,KAAK,MAAM,mBAAmB;AACrC,OAAO,oCAAoC;AAE3C,IAAMC,SAAS,GAAG,CAAC,eAAe,EAAE,gBAAgB,EAAE,aAAa,CAAC;EAClEC,UAAU,GAAG,CAAC,MAAM,CAAC;AACvB;AAAA,IACMC,aAAa;EAAA;EAAA;EACjB;;EAEA;;EAEA;;EAEA;AACF;AACA;EACE,uBAAYC,IAAI,EAAE;IAAA;IAAA;IAChB,0BAAMC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,aAAa,CAACI,QAAQ,EAAEH,IAAI,CAAC;IACrD,MAAKI,WAAW,GAAG,IAAI;IAAC;EAC1B;;EAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,iBAAQJ,IAAI,EAAE;MACZ,2EAAcA,IAAI;MAClB,IAAI,MAAM,IAAIA,IAAI,EAAE;QAClB;QACA,IAAI,CAACK,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACP,IAAI,CAACQ,IAAI,CAAC,GAAGR,IAAI,CAACQ,IAAI,CAACC,GAAG,CAAC,UAAAC,CAAC;UAAA,OAAIhB,UAAU,CAACgB,CAAC,CAAC;QAAA,EAAC,GAAG,EAAE;;QAEtF;MACF;IACF;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,wBAAeC,EAAE,EAAE;MACjB,IAAIC,KAAK,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAClF,IAAMG,OAAO,GAAG,IAAI,CAACC,cAAc,CAACN,EAAE,EAAEC,KAAK,CAAC;MAC9C,IAAI,IAAI,CAACR,WAAW,EAAE;QACpBY,OAAO,CAACE,SAAS,CAAC,IAAI,CAACd,WAAW,CAACe,WAAW,CAACR,EAAE,EAAE,IAAI,CAACS,gBAAgB,CAACR,KAAK,CAAC,CAAC,CAAC;MACnF;MACA,OAAOI,OAAO;IAChB;EAAC;IAAA;IAAA,OACD,0BAAiB;MACf,IAAIK,QAAQ,GAAGR,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;MACrF,IAAID,KAAK,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAClF,IAAIS,IAAI,GAAGT,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;MACjF,IAAMU,mBAAmB,GAAGX,KAAK,CAACU,IAAI,IAAIV,KAAK,CAACY,gBAAgB,IAAI,IAAI,GAAGZ,KAAK,CAACY,gBAAgB,CAACC,MAAM,GAAG,IAAI,CAACC,KAAK;MACrH,IAAMC,UAAU,GAAG,IAAI,CAACC,aAAa;MACrC,IAAMC,WAAW,GAAGjB,KAAK,CAACU,IAAI,IAAIV,KAAK,CAACY,gBAAgB,IAAI,IAAI;MAChE;MACAZ,KAAK,CAACY,gBAAgB,CAACM,cAAc,GAAGH,UAAU;MAClD,IAAMI,SAAS,GAAGJ,UAAU,CAACK,KAAK,CAACH,WAAW,CAACf,MAAM,CAAC;MACtD,IAAMmB,QAAQ,GAAG,IAAI,CAAC7B,WAAW;MACjC,IAAMY,OAAO,GAAG,IAAIvB,aAAa,EAAE;MACnC,IAAMyC,aAAa,GAAGD,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,KAAK;;MAExF;MACA,IAAI,CAAC/B,WAAW,GAAG,IAAI,CAACgC,UAAU,CAACf,QAAQ,EAAEpB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEU,KAAK,CAAC,EAAEU,IAAI,CAAC;;MAE5E;MACA,IAAI,IAAI,CAAClB,WAAW,EAAE;QACpB,IAAI,IAAI,CAACA,WAAW,KAAK6B,QAAQ,EAAE;UACjC;UACA,IAAI,CAAC7B,WAAW,CAACiC,KAAK,EAAE;UACxB,IAAIR,WAAW,EAAE;YACf;YACA,IAAMS,CAAC,GAAG,IAAI,CAAClC,WAAW,CAACmC,MAAM,CAACV,WAAW,EAAE;cAC7CW,GAAG,EAAE;YACP,CAAC,CAAC;YACFxB,OAAO,CAACyB,SAAS,GAAGH,CAAC,CAACI,QAAQ,CAAC5B,MAAM,GAAGS,mBAAmB,CAACT,MAAM;UACpE;UACA,IAAIiB,SAAS,EAAE;YACb;YACAf,OAAO,CAACyB,SAAS,IAAI,IAAI,CAACrC,WAAW,CAACmC,MAAM,CAACR,SAAS,EAAE;cACtDS,GAAG,EAAE,IAAI;cACTlB,IAAI,EAAE;YACR,CAAC,CAAC,CAACmB,SAAS;UACd;QACF,CAAC,MAAM;UACL;UACA;UACA,IAAI,CAACrC,WAAW,CAAC+B,KAAK,GAAGD,aAAa;QACxC;MACF;MACA,OAAOlB,OAAO;IAChB;EAAC;IAAA;IAAA,OACD,8BAAqB;MACnB,IAAMA,OAAO,GAAG,IAAI,CAACC,cAAc,OAAnB,IAAI,EAAmBJ,SAAS,CAAC;MACjD,IAAI,IAAI,CAACT,WAAW,EAAE;QACpBY,OAAO,CAACE,SAAS,CAAC,IAAI,CAACd,WAAW,CAACuC,kBAAkB,EAAE,CAAC;MAC1D;MACA,OAAO3B,OAAO;IAChB;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,wBAAe;MACb,IAAMA,OAAO,GAAG,IAAI,CAACC,cAAc,OAAnB,IAAI,EAAmBJ,SAAS,CAAC;MACjD,IAAI,IAAI,CAACT,WAAW,EAAE;QACpBY,OAAO,CAACE,SAAS,CAAC,IAAI,CAACd,WAAW,CAACwC,YAAY,EAAE,CAAC;MACpD;MACA,OAAO5B,OAAO;IAChB;EAAC;IAAA;IAAA,OACD,oBAAWM,IAAI,EAAE;MACf,IAAMN,OAAO,GAAG,IAAIvB,aAAa,EAAE;MACnC,IAAI6B,IAAI,EAAEN,OAAO,CAACE,SAAS,CAAC,IAAI,CAACD,cAAc,CAAC,EAAE,EAAE,CAAC,CAAC,EAAEK,IAAI,CAAC,CAAC;MAC9D,OAAON,OAAO,CAACE,SAAS,CAAC,IAAI,CAACd,WAAW,GAAG,IAAI,CAACA,WAAW,CAACyC,UAAU,CAACvB,IAAI,CAAC,iFAAoBA,IAAI,CAAC,CAAC;IACzG;EAAC;IAAA;IAAA,OACD,0BAAiBV,KAAK,EAAE;MACtB,IAAIkC,qBAAqB,EAAEC,sBAAsB;MACjD,OAAO9C,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEU,KAAK,EAAE;QAC9BY,gBAAgB,EAAE,CAAC,CAACsB,qBAAqB,GAAGlC,KAAK,CAACY,gBAAgB,MAAM,IAAI,IAAIsB,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACE,cAAc,MAAM,IAAI,CAAC5C,WAAW,KAAK,CAAC2C,sBAAsB,GAAGnC,KAAK,CAACY,gBAAgB,MAAM,IAAI,IAAIuB,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC3C,WAAW,CAAC,IAAIQ,KAAK,CAACY;MACrV,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,oBAAWH,QAAQ,EAAE;MACnB,IAAIT,KAAK,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAClF,IAAIS,IAAI,GAAGT,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;MACjF,OAAO,IAAI,CAACoC,QAAQ,CAAC5B,QAAQ,EAAE,IAAI,EAAET,KAAK,EAAEU,IAAI,CAAC;IACnD;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,oBAAWV,KAAK,EAAE;MAChB,OAAO,8EAAiBA,KAAK,MAAM,CAAC,IAAI,CAACR,WAAW,IAAI,IAAI,CAACA,WAAW,CAAC8C,UAAU,CAAC,IAAI,CAAC9B,gBAAgB,CAACR,KAAK,CAAC,CAAC,CAAC;IACpH;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,mBAAUuC,GAAG,EAAE;MACb,IAAIvC,KAAK,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAClF,wBAAmBtB,gBAAgB,8EAAiB4D,GAAG,EAAEvC,KAAK,EAAE;QAAA;QAA3DwC,CAAC;QAAEpC,OAAO;MACf,IAAI,IAAI,CAACZ,WAAW,EAAE;QACpB,IAAIiD,cAAc;QAAC,yBACG9D,gBAAgB,8EAAiB6D,CAAC,EAAE,IAAI,CAAChC,gBAAgB,CAACR,KAAK,CAAC,EAAE;QAAA;QAAvFwC,CAAC;QAAEC,cAAc;QAClBrC,OAAO,GAAGA,OAAO,CAACE,SAAS,CAACmC,cAAc,CAAC;MAC7C;MACA,OAAO,CAACD,CAAC,EAAEpC,OAAO,CAAC;IACrB;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,iBAAQ;MACN,IAAIsC,iBAAiB;MACrB,CAACA,iBAAiB,GAAG,IAAI,CAAClD,WAAW,MAAM,IAAI,IAAIkD,iBAAiB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,iBAAiB,CAACjB,KAAK,EAAE;MACpH,IAAI,CAAChC,aAAa,CAACkD,OAAO,CAAC,UAAA7C,CAAC;QAAA,OAAIA,CAAC,CAAC2B,KAAK,EAAE;MAAA,EAAC;IAC5C;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAY;MACV,OAAO,IAAI,CAACjC,WAAW,GAAG,IAAI,CAACA,WAAW,CAACsB,KAAK,GAAG,EAAE;IACvD,CAAC;IAAA,KACD,aAAUA,KAAK,EAAE;MACf,wDAAcA,KAAK;IACrB;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAoB;MAClB,OAAO,IAAI,CAACtB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACoD,aAAa,GAAG,EAAE;IAC/D,CAAC;IAAA,KACD,aAAkBA,aAAa,EAAE;MAC/B,gEAAsBA,aAAa;IACrC;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAiB;MACf,OAAO,IAAI,CAACpD,WAAW,GAAG,IAAI,CAACA,WAAW,CAACqD,UAAU,GAAG,EAAE;IAC5D;;IAEA;IAAA;IAAA,KACA,aAAe/B,KAAK,EAAE;MACpB,IAAI8B,aAAa,GAAGE,MAAM,CAAChC,KAAK,CAAC;;MAEjC;MACA,IAAI,IAAI,CAACtB,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,CAACqD,UAAU,GAAG/B,KAAK;QACnC8B,aAAa,GAAG,IAAI,CAACpD,WAAW,CAACoD,aAAa;MAChD;MACA,IAAI,CAACA,aAAa,GAAGA,aAAa;IACpC;EAAC;IAAA;IAAA,KACD,eAAmB;MACjB,OAAO,IAAI,CAACpD,WAAW,GAAG,IAAI,CAACA,WAAW,CAACuD,YAAY,GAAG,EAAE;IAC9D;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAiB;MACf,IAAIC,kBAAkB;MACtB,OAAOC,OAAO,CAAC,CAACD,kBAAkB,GAAG,IAAI,CAACxD,WAAW,MAAM,IAAI,IAAIwD,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAACE,UAAU,CAAC;IAC5I;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAe;MACb,IAAIC,kBAAkB;MACtB,OAAOF,OAAO,CAAC,CAACE,kBAAkB,GAAG,IAAI,CAAC3D,WAAW,MAAM,IAAI,IAAI2D,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAACC,QAAQ,CAAC;IAC1I;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,kBAAS;MACP,IAAMhD,OAAO,GAAG,IAAIvB,aAAa,EAAE;MACnC,IAAI,IAAI,CAACW,WAAW,EAAE;QAAA;QACpBY,OAAO,CAACE,SAAS,CAAC,0BAAI,CAACd,WAAW,EAAC6D,MAAM,2BAAIpD,SAAS,CAAC;QACvD;QAAA,CACCK,SAAS,CAAC,IAAI,CAACD,cAAc,EAAE,CAAC;MACnC;MACA,OAAOD,OAAO;IAChB;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,KAGA,eAAY;MACV,IAAIkD,kBAAkB;MACtB,OAAOjE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,iEAAe;QACpC4B,cAAc,EAAE,IAAI,CAACF,aAAa;QAClCvB,aAAa,EAAE,IAAI,CAACA,aAAa,CAACI,GAAG,CAAC,UAAAC,CAAC;UAAA,OAAIA,CAAC,CAACyB,KAAK;QAAA,EAAC;QACnDa,cAAc,EAAE,IAAI,CAAC5C,WAAW;QAChCA,WAAW,EAAE,CAAC8D,kBAAkB,GAAG,IAAI,CAAC9D,WAAW,MAAM,IAAI,IAAI8D,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAAC/B;MAC/H,CAAC,CAAC;IACJ,CAAC;IAAA,KACD,aAAUA,KAAK,EAAE;MACf,IACI9B,aAAa,GAGX8B,KAAK,CAHP9B,aAAa;QACb2C,cAAc,GAEZb,KAAK,CAFPa,cAAc;QACd5C,WAAW,GACT+B,KAAK,CADP/B,WAAW;QAEb+D,WAAW,GAAG9E,6BAA6B,CAAC8C,KAAK,EAAEtC,SAAS,CAAC;MAC/D,IAAI,CAACQ,aAAa,CAACkD,OAAO,CAAC,UAAC7C,CAAC,EAAE0D,EAAE;QAAA,OAAK1D,CAAC,CAACyB,KAAK,GAAG9B,aAAa,CAAC+D,EAAE,CAAC;MAAA,EAAC;MAClE,IAAIpB,cAAc,IAAI,IAAI,EAAE;QAC1B,IAAI,CAAC5C,WAAW,GAAG4C,cAAc;QACjC,IAAI,CAAC5C,WAAW,CAAC+B,KAAK,GAAG/B,WAAW;MACtC;MACA,wDAAc+D,WAAW;IAC3B;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,wBAAe;MAAA;MACb,OAAO,IAAI,CAAC/D,WAAW,GAAG,0BAAI,CAACA,WAAW,EAACiE,YAAY,2BAAIxD,SAAS,CAAC,GAAG,EAAE;IAC5E;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,uBAAc;MAAA;MACZ,OAAO,IAAI,CAACT,WAAW,GAAG,0BAAI,CAACA,WAAW,EAACkE,WAAW,2BAAIzD,SAAS,CAAC,mFAAwBA,SAAS,CAAC;IACxG;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,oBAAW;MACT,IAAI,IAAI,CAACT,WAAW,EAAE,IAAI,CAACA,WAAW,CAACmE,QAAQ,EAAE;MACjD;IACF;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,2BAAkB;MAAA;MAChB,OAAO,IAAI,CAACnE,WAAW,GAAG,0BAAI,CAACA,WAAW,EAACoE,eAAe,2BAAI3D,SAAS,CAAC,uFAA4BA,SAAS,CAAC;IAChH;EAAC;IAAA;IAAA,KACD,eAAgB;MACd,OAAO,IAAI,CAACT,WAAW,GAAG,IAAI,CAACA,WAAW,CAACqE,SAAS,oEAAkB;IACxE,CAAC;IAAA,KACD,aAAcA,SAAS,EAAE;MACvBC,OAAO,CAACC,IAAI,CAAC,kFAAkF,CAAC;IAClG;EAAC;IAAA;IAAA,KACD,eAAY;MACV,OAAO,IAAI,CAACvE,WAAW,GAAG,IAAI,CAACA,WAAW,CAACwE,KAAK,gEAAc;IAChE,CAAC;IAAA,KACD,aAAUA,KAAK,EAAE;MACfF,OAAO,CAACC,IAAI,CAAC,8EAA8E,CAAC;IAC9F;EAAC;IAAA;IAAA,KACD,eAAkB;MAChB,OAAO,IAAI,CAACvE,WAAW,GAAG,IAAI,CAACA,WAAW,CAACyE,WAAW,sEAAoB;IAC5E,CAAC;IAAA,KACD,aAAgBA,WAAW,EAAE;MAC3B,IAAI,IAAI,CAACC,aAAa,IAAID,WAAW,KAAKlF,MAAM,CAACQ,QAAQ,CAAC0E,WAAW,EAAE;QACrEH,OAAO,CAACC,IAAI,CAAC,oFAAoF,CAAC;MACpG;IACF;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,oBAAWnE,IAAI,EAAE;MACf,OAAOF,KAAK,CAACC,OAAO,CAACC,IAAI,CAAC,IAAI,IAAI,CAACH,aAAa,CAAC0E,KAAK,CAAC,UAACrE,CAAC,EAAE0D,EAAE,EAAK;QAChE,IAAI,CAAC5D,IAAI,CAAC4D,EAAE,CAAC,EAAE;QACT,IAAAY,QAAQ,GAAGxE,IAAI,CAAC4D,EAAE,CAAC;UAEfa,OAAO,GACXD,QAAQ,CADVxE,IAAI;UAEN0E,QAAQ,GAAG7F,6BAA6B,CAAC2F,QAAQ,EAAElF,UAAU,CAAC;QAChE,OAAON,cAAc,CAACkB,CAAC,EAAEwE,QAAQ,CAAC,IAAIxE,CAAC,CAACyE,UAAU,CAACF,OAAO,CAAC;MAC7D,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,0BAAiBvD,KAAK,EAAE;MACtB,IAAI0D,kBAAkB;MACtB,OAAOvB,OAAO,CAAC,CAACuB,kBAAkB,GAAG,IAAI,CAAChF,WAAW,MAAM,IAAI,IAAIgF,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAACC,gBAAgB,CAAC3D,KAAK,CAAC,CAAC;IACzJ;EAAC;EAAA;AAAA,EAhUyB/B,MAAM;AAkUlCI,aAAa,CAACI,QAAQ,GAAG;EACvB8C,QAAQ,EAAE,kBAAC5B,QAAQ,EAAEiE,MAAM,EAAE1E,KAAK,EAAEU,IAAI,EAAK;IAC3C,IAAI,CAACgE,MAAM,CAACjF,aAAa,CAACS,MAAM,EAAE;IAClC,IAAMa,UAAU,GAAG2D,MAAM,CAAC1D,aAAa;;IAEvC;IACA,IAAM2D,MAAM,GAAGD,MAAM,CAACjF,aAAa,CAACI,GAAG,CAAC,UAACC,CAAC,EAAE8E,KAAK,EAAK;MACpD,IAAMC,SAAS,GAAGH,MAAM,CAAClF,WAAW,KAAKM,CAAC;MAC1C,IAAMgF,aAAa,GAAGD,SAAS,GAAG/E,CAAC,CAACgB,KAAK,CAACZ,MAAM,GAAGJ,CAAC,CAAC8D,eAAe,CAAC9D,CAAC,CAACgB,KAAK,CAACZ,MAAM,EAAExB,SAAS,CAACqG,UAAU,CAAC;MAC1G,IAAIjF,CAAC,CAACkB,aAAa,KAAKD,UAAU,EAAE;QAClCjB,CAAC,CAAC2B,KAAK,EAAE;QACT3B,CAAC,CAAC6B,MAAM,CAACZ,UAAU,EAAE;UACnBa,GAAG,EAAE;QACP,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI,CAACiD,SAAS,EAAE;QACrB/E,CAAC,CAACuD,MAAM,CAACyB,aAAa,CAAC;MACzB;MACAhF,CAAC,CAAC6B,MAAM,CAAClB,QAAQ,EAAEiE,MAAM,CAAClE,gBAAgB,CAACR,KAAK,CAAC,CAAC;MAClDF,CAAC,CAACmC,UAAU,CAACvB,IAAI,CAAC;MAClB,OAAO;QACLkE,KAAK,EAALA,KAAK;QACLI,MAAM,EAAElF,CAAC,CAACkB,aAAa,CAACd,MAAM;QAC9B+E,mBAAmB,EAAEnF,CAAC,CAACmF,mBAAmB,CAAC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACL,aAAa,EAAEhF,CAAC,CAAC8D,eAAe,CAAC9D,CAAC,CAACgB,KAAK,CAACZ,MAAM,EAAExB,SAAS,CAACqG,UAAU,CAAC,CAAC;MAChI,CAAC;IACH,CAAC,CAAC;;IAEF;IACAJ,MAAM,CAACS,IAAI,CAAC,UAACC,EAAE,EAAEC,EAAE;MAAA,OAAKA,EAAE,CAACN,MAAM,GAAGK,EAAE,CAACL,MAAM,IAAIM,EAAE,CAACL,mBAAmB,GAAGI,EAAE,CAACJ,mBAAmB;IAAA,EAAC;IACjG,OAAOP,MAAM,CAACjF,aAAa,CAACkF,MAAM,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC;EAC9C;AACF,CAAC;AACD5F,KAAK,CAACG,aAAa,GAAGA,aAAa;AAEnC,SAASA,aAAa,IAAIoG,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}