{"ast":null,"code":"import _classCallCheck from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _set from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/set.js\";\nimport _get from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n  var _super = _createSuper(MaskedPattern);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  function MaskedPattern() {\n    _classCallCheck(this, MaskedPattern);\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n      this._rebuildMask();\n    }\n\n    /** */\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n      var _loop = function _loop(_i) {\n        if (_this.blocks) {\n          var p = pattern.slice(_i);\n          var bNames = Object.keys(_this.blocks).filter(function (bName) {\n            return p.indexOf(bName) === 0;\n          });\n          // order by key length\n          bNames.sort(function (a, b) {\n            return b.length - a.length;\n          });\n          // use block name with max length\n          var bName = bNames[0];\n          if (bName) {\n            // $FlowFixMe no ideas\n            var maskedBlock = createMask(Object.assign({\n              parent: _this,\n              lazy: _this.lazy,\n              eager: _this.eager,\n              placeholderChar: _this.placeholderChar,\n              displayChar: _this.displayChar,\n              overwrite: _this.overwrite\n            }, _this.blocks[bName]));\n            if (maskedBlock) {\n              _this._blocks.push(maskedBlock);\n\n              // store block index\n              if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n              _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n            }\n            _i += bName.length - 1;\n            i = _i;\n            return \"continue\";\n          }\n        }\n        var char = pattern[_i];\n        var isInput = (char in defs);\n        if (char === MaskedPattern.STOP_CHAR) {\n          _this._stops.push(_this._blocks.length);\n          i = _i;\n          return \"continue\";\n        }\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          i = _i;\n          return \"continue\";\n        }\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          i = _i;\n          return \"continue\";\n        }\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++_i;\n          char = pattern[_i];\n          if (!char) {\n            i = _i;\n            return \"break\";\n          }\n          isInput = false;\n        }\n        var maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n          mask: defs[char]\n        };\n        var def = isInput ? new PatternInputDefinition(Object.assign({\n          parent: _this,\n          isOptional: optionalBlock,\n          lazy: _this.lazy,\n          eager: _this.eager,\n          placeholderChar: _this.placeholderChar,\n          displayChar: _this.displayChar\n        }, maskOpts)) : new PatternFixedDefinition({\n          char: char,\n          eager: _this.eager,\n          isUnmasking: unmaskingBlock\n        });\n        _this._blocks.push(def);\n        i = _i;\n      };\n      for (var i = 0; i < pattern.length; ++i) {\n        var _defs$char, _defs$char2;\n        var _ret = _loop(i);\n        if (_ret === \"continue\") continue;\n        if (_ret === \"break\") break;\n      }\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n        maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n  }, {\n    key: \"displayValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.displayValue;\n      }, '');\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details;\n\n      // TODO test if it works for nested pattern masks\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n      return details;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var blockIter = this._mapPosToBlock(this.value.length);\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n        var block = this._blocks[bi];\n        if (!block) break;\n        var blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n        }));\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n      return chunkTail;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n      return stopBefore;\n    }\n\n    /** Appends placeholder depending on laziness */\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n          var bDetails = b._appendPlaceholder.apply(b, args);\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n      return details;\n    }\n\n    /** Finds block in pos */\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var block = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += block.value;\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n\n    /** */\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n\n    /** */\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos);\n        // process first block\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          }\n\n          // process last block\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n      return removeDetails;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      }\n\n      // FORCE is only about a|* otherwise is 0\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        }\n\n        // forward flow\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled();\n\n        // backward flow\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n\n        // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n        // backward flow\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n      return cursorPos;\n    }\n\n    /**\n      @override\n    */\n  }, {\n    key: \"totalInputPositions\",\n    value: function totalInputPositions() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var total = 0;\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        total += b.totalInputPositions(bFromPos, bToPos);\n      });\n      return total;\n    }\n\n    /** Get block by name */\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n\n    /** Get all blocks by name */\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","opts","arguments","length","undefined","definitions","Object","assign","DEFAULTS","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","parent","lazy","eager","placeholderChar","displayChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","maskOpts","_defs$char","_defs$char2","prototype","def","isOptional","isUnmasking","i","map","state","maskedState","forEach","bi","reset","every","isComplete","isFilled","isFixed","doCommit","reduce","str","unmaskedValue","value","displayValue","tail","aggregate","_appendPlaceholder","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","_appendEager","inserted","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","extractTail","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","input","extractInput","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","args","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","removeDetails","remove","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","nearestInputPos","total","totalInputPositions","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["C:/Users/admin/Desktop/Документы/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}