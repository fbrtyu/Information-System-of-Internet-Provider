{"ast":null,"code":"import _classCallCheck from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nvar _excluded = [\"chunks\"];\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n\n  function ChunksTailDetails() {\n    _classCallCheck(this, ChunksTailDetails);\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    }\n\n    // $FlowFixMe no ideas\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && (\n      // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n      // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        }\n\n        // if tail chunk still has value\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n      var details = new ChangeDetails();\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n        if (stop != null && (\n        // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails ||\n          // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            var phDetails = masked._appendPlaceholder(stop);\n            details.aggregate(phDetails);\n          }\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted;\n\n          // get not inserted chars\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n        props = _objectWithoutPropertiesLoose(state, _excluded);\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n        // $FlowFixMe already checked above\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n  }]);\n  return ChunksTailDetails;\n}();\nexport { ChunksTailDetails as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","chunks","arguments","length","undefined","from","map","String","join","tailChunk","lastChunk","extendLast","stop","toString","extend","push","firstTailChunk","shift","blockIndex","masked","MaskedPattern","tail","appendTo","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","value","chunkBlock","index","_stops","indexOf","phDetails","_appendPlaceholder","aggregate","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","c","state","props","Object","assign","cstate","beforePos","chunkShiftPos","shiftChar","unshift","splice","default"],"sources":["C:/Users/admin/Desktop/Документы/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nconst _excluded = [\"chunks\"];\nclass ChunksTailDetails {\n  /** */\n\n  constructor() {\n    let chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n  toString() {\n    return this.chunks.map(String).join('');\n  }\n\n  // $FlowFixMe no ideas\n  extend(tailChunk) {\n    if (!String(tailChunk)) return;\n    if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n    const lastChunk = this.chunks[this.chunks.length - 1];\n    const extendLast = lastChunk && (\n    // if stops are same or tail has no stop\n    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n    // if tail chunk goes just after last chunk\n    tailChunk.from === lastChunk.from + lastChunk.toString().length;\n    if (tailChunk instanceof ContinuousTailDetails) {\n      // check the ability to extend previous chunk\n      if (extendLast) {\n        // extend previous chunk\n        lastChunk.extend(tailChunk.toString());\n      } else {\n        // append new chunk\n        this.chunks.push(tailChunk);\n      }\n    } else if (tailChunk instanceof ChunksTailDetails) {\n      if (tailChunk.stop == null) {\n        // unwrap floating chunks to parent, keeping `from` pos\n        let firstTailChunk;\n        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n          firstTailChunk = tailChunk.chunks.shift();\n          firstTailChunk.from += tailChunk.from;\n          this.extend(firstTailChunk);\n        }\n      }\n\n      // if tail chunk still has value\n      if (tailChunk.toString()) {\n        // if chunks contains stops, then popup stop to container\n        tailChunk.stop = tailChunk.blockIndex;\n        this.chunks.push(tailChunk);\n      }\n    }\n  }\n  appendTo(masked) {\n    // $FlowFixMe\n    if (!(masked instanceof IMask.MaskedPattern)) {\n      const tail = new ContinuousTailDetails(this.toString());\n      return tail.appendTo(masked);\n    }\n    const details = new ChangeDetails();\n    for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n      const chunk = this.chunks[ci];\n      const lastBlockIter = masked._mapPosToBlock(masked.value.length);\n      const stop = chunk.stop;\n      let chunkBlock;\n      if (stop != null && (\n      // if block not found or stop is behind lastBlock\n      !lastBlockIter || lastBlockIter.index <= stop)) {\n        if (chunk instanceof ChunksTailDetails ||\n        // for continuous block also check if stop is exist\n        masked._stops.indexOf(stop) >= 0) {\n          const phDetails = masked._appendPlaceholder(stop);\n          details.aggregate(phDetails);\n        }\n        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n      }\n      if (chunkBlock) {\n        const tailDetails = chunkBlock.appendTail(chunk);\n        tailDetails.skip = false; // always ignore skip, it will be set on last\n        details.aggregate(tailDetails);\n        masked._value += tailDetails.inserted;\n\n        // get not inserted chars\n        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n        if (remainChars) details.aggregate(masked.append(remainChars, {\n          tail: true\n        }));\n      } else {\n        details.aggregate(masked.append(chunk.toString(), {\n          tail: true\n        }));\n      }\n    }\n    return details;\n  }\n  get state() {\n    return {\n      chunks: this.chunks.map(c => c.state),\n      from: this.from,\n      stop: this.stop,\n      blockIndex: this.blockIndex\n    };\n  }\n  set state(state) {\n    const {\n        chunks\n      } = state,\n      props = _objectWithoutPropertiesLoose(state, _excluded);\n    Object.assign(this, props);\n    this.chunks = chunks.map(cstate => {\n      const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n      // $FlowFixMe already checked above\n      chunk.state = cstate;\n      return chunk;\n    });\n  }\n  unshift(beforePos) {\n    if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n    const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n    let ci = 0;\n    while (ci < this.chunks.length) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.unshift(chunkShiftPos);\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        ++ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n  shift() {\n    if (!this.chunks.length) return '';\n    let ci = this.chunks.length - 1;\n    while (0 <= ci) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.shift();\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        --ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n}\n\nexport { ChunksTailDetails as default };\n"],"mappings":";;AAAA,SAASA,CAAC,IAAIC,6BAA6B,QAAQ,6CAA6C;AAChG,OAAOC,aAAa,MAAM,8BAA8B;AACxD,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,OAAOC,qBAAqB,MAAM,uCAAuC;AACzE,OAAOC,KAAK,MAAM,sBAAsB;AAExC,IAAMC,SAAS,GAAG,CAAC,QAAQ,CAAC;AAAC,IACvBC,iBAAiB;EACrB;;EAEA,6BAAc;IAAA;IACZ,IAAIC,MAAM,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;IACnF,IAAIG,IAAI,GAAGH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;IAChF,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACI,IAAI,GAAGA,IAAI;EAClB;EAAC;IAAA;IAAA,OACD,oBAAW;MACT,OAAO,IAAI,CAACJ,MAAM,CAACK,GAAG,CAACC,MAAM,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;IACzC;;IAEA;EAAA;IAAA;IAAA,OACA,gBAAOC,SAAS,EAAE;MAChB,IAAI,CAACF,MAAM,CAACE,SAAS,CAAC,EAAE;MACxB,IAAIb,QAAQ,CAACa,SAAS,CAAC,EAAEA,SAAS,GAAG,IAAIZ,qBAAqB,CAACU,MAAM,CAACE,SAAS,CAAC,CAAC;MACjF,IAAMC,SAAS,GAAG,IAAI,CAACT,MAAM,CAAC,IAAI,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC;MACrD,IAAMQ,UAAU,GAAGD,SAAS;MAC5B;MACAA,SAAS,CAACE,IAAI,KAAKH,SAAS,CAACG,IAAI,IAAIH,SAAS,CAACG,IAAI,IAAI,IAAI,CAAC;MAC5D;MACAH,SAAS,CAACJ,IAAI,KAAKK,SAAS,CAACL,IAAI,GAAGK,SAAS,CAACG,QAAQ,EAAE,CAACV,MAAM;MAC/D,IAAIM,SAAS,YAAYZ,qBAAqB,EAAE;QAC9C;QACA,IAAIc,UAAU,EAAE;UACd;UACAD,SAAS,CAACI,MAAM,CAACL,SAAS,CAACI,QAAQ,EAAE,CAAC;QACxC,CAAC,MAAM;UACL;UACA,IAAI,CAACZ,MAAM,CAACc,IAAI,CAACN,SAAS,CAAC;QAC7B;MACF,CAAC,MAAM,IAAIA,SAAS,YAAYT,iBAAiB,EAAE;QACjD,IAAIS,SAAS,CAACG,IAAI,IAAI,IAAI,EAAE;UAC1B;UACA,IAAII,cAAc;UAClB,OAAOP,SAAS,CAACR,MAAM,CAACE,MAAM,IAAIM,SAAS,CAACR,MAAM,CAAC,CAAC,CAAC,CAACW,IAAI,IAAI,IAAI,EAAE;YAClEI,cAAc,GAAGP,SAAS,CAACR,MAAM,CAACgB,KAAK,EAAE;YACzCD,cAAc,CAACX,IAAI,IAAII,SAAS,CAACJ,IAAI;YACrC,IAAI,CAACS,MAAM,CAACE,cAAc,CAAC;UAC7B;QACF;;QAEA;QACA,IAAIP,SAAS,CAACI,QAAQ,EAAE,EAAE;UACxB;UACAJ,SAAS,CAACG,IAAI,GAAGH,SAAS,CAACS,UAAU;UACrC,IAAI,CAACjB,MAAM,CAACc,IAAI,CAACN,SAAS,CAAC;QAC7B;MACF;IACF;EAAC;IAAA;IAAA,OACD,kBAASU,MAAM,EAAE;MACf;MACA,IAAI,EAAEA,MAAM,YAAYrB,KAAK,CAACsB,aAAa,CAAC,EAAE;QAC5C,IAAMC,IAAI,GAAG,IAAIxB,qBAAqB,CAAC,IAAI,CAACgB,QAAQ,EAAE,CAAC;QACvD,OAAOQ,IAAI,CAACC,QAAQ,CAACH,MAAM,CAAC;MAC9B;MACA,IAAMI,OAAO,GAAG,IAAI5B,aAAa,EAAE;MACnC,KAAK,IAAI6B,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG,IAAI,CAACvB,MAAM,CAACE,MAAM,IAAI,CAACoB,OAAO,CAACE,IAAI,EAAE,EAAED,EAAE,EAAE;QAC/D,IAAME,KAAK,GAAG,IAAI,CAACzB,MAAM,CAACuB,EAAE,CAAC;QAC7B,IAAMG,aAAa,GAAGR,MAAM,CAACS,cAAc,CAACT,MAAM,CAACU,KAAK,CAAC1B,MAAM,CAAC;QAChE,IAAMS,IAAI,GAAGc,KAAK,CAACd,IAAI;QACvB,IAAIkB,UAAU;QACd,IAAIlB,IAAI,IAAI,IAAI;QAChB;QACA,CAACe,aAAa,IAAIA,aAAa,CAACI,KAAK,IAAInB,IAAI,CAAC,EAAE;UAC9C,IAAIc,KAAK,YAAY1B,iBAAiB;UACtC;UACAmB,MAAM,CAACa,MAAM,CAACC,OAAO,CAACrB,IAAI,CAAC,IAAI,CAAC,EAAE;YAChC,IAAMsB,SAAS,GAAGf,MAAM,CAACgB,kBAAkB,CAACvB,IAAI,CAAC;YACjDW,OAAO,CAACa,SAAS,CAACF,SAAS,CAAC;UAC9B;UACAJ,UAAU,GAAGJ,KAAK,YAAY1B,iBAAiB,IAAImB,MAAM,CAACkB,OAAO,CAACzB,IAAI,CAAC;QACzE;QACA,IAAIkB,UAAU,EAAE;UACd,IAAMQ,WAAW,GAAGR,UAAU,CAACS,UAAU,CAACb,KAAK,CAAC;UAChDY,WAAW,CAACb,IAAI,GAAG,KAAK,CAAC,CAAC;UAC1BF,OAAO,CAACa,SAAS,CAACE,WAAW,CAAC;UAC9BnB,MAAM,CAACqB,MAAM,IAAIF,WAAW,CAACG,QAAQ;;UAErC;UACA,IAAMC,WAAW,GAAGhB,KAAK,CAACb,QAAQ,EAAE,CAAC8B,KAAK,CAACL,WAAW,CAACM,WAAW,CAACzC,MAAM,CAAC;UAC1E,IAAIuC,WAAW,EAAEnB,OAAO,CAACa,SAAS,CAACjB,MAAM,CAAC0B,MAAM,CAACH,WAAW,EAAE;YAC5DrB,IAAI,EAAE;UACR,CAAC,CAAC,CAAC;QACL,CAAC,MAAM;UACLE,OAAO,CAACa,SAAS,CAACjB,MAAM,CAAC0B,MAAM,CAACnB,KAAK,CAACb,QAAQ,EAAE,EAAE;YAChDQ,IAAI,EAAE;UACR,CAAC,CAAC,CAAC;QACL;MACF;MACA,OAAOE,OAAO;IAChB;EAAC;IAAA;IAAA,KACD,eAAY;MACV,OAAO;QACLtB,MAAM,EAAE,IAAI,CAACA,MAAM,CAACK,GAAG,CAAC,UAAAwC,CAAC;UAAA,OAAIA,CAAC,CAACC,KAAK;QAAA,EAAC;QACrC1C,IAAI,EAAE,IAAI,CAACA,IAAI;QACfO,IAAI,EAAE,IAAI,CAACA,IAAI;QACfM,UAAU,EAAE,IAAI,CAACA;MACnB,CAAC;IACH,CAAC;IAAA,KACD,aAAU6B,KAAK,EAAE;MACT,IACF9C,MAAM,GACJ8C,KAAK,CADP9C,MAAM;QAER+C,KAAK,GAAGtD,6BAA6B,CAACqD,KAAK,EAAEhD,SAAS,CAAC;MACzDkD,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEF,KAAK,CAAC;MAC1B,IAAI,CAAC/C,MAAM,GAAGA,MAAM,CAACK,GAAG,CAAC,UAAA6C,MAAM,EAAI;QACjC,IAAMzB,KAAK,GAAG,QAAQ,IAAIyB,MAAM,GAAG,IAAInD,iBAAiB,EAAE,GAAG,IAAIH,qBAAqB,EAAE;QACxF;QACA6B,KAAK,CAACqB,KAAK,GAAGI,MAAM;QACpB,OAAOzB,KAAK;MACd,CAAC,CAAC;IACJ;EAAC;IAAA;IAAA,OACD,iBAAQ0B,SAAS,EAAE;MACjB,IAAI,CAAC,IAAI,CAACnD,MAAM,CAACE,MAAM,IAAIiD,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC/C,IAAI,IAAI+C,SAAS,EAAE,OAAO,EAAE;MACjF,IAAMC,aAAa,GAAGD,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAG,IAAI,CAAC/C,IAAI,GAAG+C,SAAS;MAC3E,IAAI5B,EAAE,GAAG,CAAC;MACV,OAAOA,EAAE,GAAG,IAAI,CAACvB,MAAM,CAACE,MAAM,EAAE;QAC9B,IAAMuB,KAAK,GAAG,IAAI,CAACzB,MAAM,CAACuB,EAAE,CAAC;QAC7B,IAAM8B,SAAS,GAAG5B,KAAK,CAAC6B,OAAO,CAACF,aAAa,CAAC;QAC9C,IAAI3B,KAAK,CAACb,QAAQ,EAAE,EAAE;UACpB;UACA;UACA,IAAI,CAACyC,SAAS,EAAE;UAChB,EAAE9B,EAAE;QACN,CAAC,MAAM;UACL;UACA,IAAI,CAACvB,MAAM,CAACuD,MAAM,CAAChC,EAAE,EAAE,CAAC,CAAC;QAC3B;QACA,IAAI8B,SAAS,EAAE,OAAOA,SAAS;MACjC;MACA,OAAO,EAAE;IACX;EAAC;IAAA;IAAA,OACD,iBAAQ;MACN,IAAI,CAAC,IAAI,CAACrD,MAAM,CAACE,MAAM,EAAE,OAAO,EAAE;MAClC,IAAIqB,EAAE,GAAG,IAAI,CAACvB,MAAM,CAACE,MAAM,GAAG,CAAC;MAC/B,OAAO,CAAC,IAAIqB,EAAE,EAAE;QACd,IAAME,KAAK,GAAG,IAAI,CAACzB,MAAM,CAACuB,EAAE,CAAC;QAC7B,IAAM8B,SAAS,GAAG5B,KAAK,CAACT,KAAK,EAAE;QAC/B,IAAIS,KAAK,CAACb,QAAQ,EAAE,EAAE;UACpB;UACA;UACA,IAAI,CAACyC,SAAS,EAAE;UAChB,EAAE9B,EAAE;QACN,CAAC,MAAM;UACL;UACA,IAAI,CAACvB,MAAM,CAACuD,MAAM,CAAChC,EAAE,EAAE,CAAC,CAAC;QAC3B;QACA,IAAI8B,SAAS,EAAE,OAAOA,SAAS;MACjC;MACA,OAAO,EAAE;IACX;EAAC;EAAA;AAAA;AAGH,SAAStD,iBAAiB,IAAIyD,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}