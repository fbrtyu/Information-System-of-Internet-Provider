{"ast":null,"code":"import _slicedToArray from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/admin/Desktop/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */ // $FlowFixMe no ideas\n  /** Transforms value before mask processing */\n  /** Validates if value is acceptable */\n  /** Does additional processing in the end of editing */\n  /** Format typed value to string */\n  /** Parse strgin to get typed value */\n  /** Enable characters overwriting */\n  /** */\n  /** */\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n    this._value = '';\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n    this.isInitialized = true;\n  }\n\n  /** Sets and applies new options */\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      // $FlowFixMe\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n\n    /**\n      Sets new options\n      @protected\n    */\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n\n    /** Mask state */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n\n    /** Resets value */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n\n    /** */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n\n    /** Resolve new value */\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n\n    /** */\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n\n    /** */\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n\n    /** Value that includes raw user input */\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n  }, {\n    key: \"displayValue\",\n    get: function get() {\n      return this.value;\n    }\n\n    /** */\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n\n    /** */\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this.isComplete;\n    }\n\n    /** Finds nearest input position in direction */\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n  }, {\n    key: \"totalInputPositions\",\n    value: function totalInputPositions() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return Math.min(this.value.length, toPos - fromPos);\n    }\n\n    /** Extracts value in range considering flags */\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n\n    /** Extracts tail in range */\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n\n    /** Appends tail */\n    // $FlowFixMe no ideas\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n\n    /** Appends char */\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n\n    /** Appends char */\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n      var details;\n      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));\n      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);\n      ch = _normalizePrepare2[0];\n      details = _normalizePrepare2[1];\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            checkTail.unshift(this.value.length - details.tailShift);\n          }\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n\n          // not ok, try shift\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            checkTail.shift();\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted === checkTail.toString();\n          }\n\n          // if ok, rollback state after tail\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        }\n\n        // revert all if something went wrong\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n      return details;\n    }\n\n    /** Appends optional placeholder at end */\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n\n    /** Appends optional eager placeholder at end */\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      return new ChangeDetails();\n    }\n\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n      for (var ci = 0; ci < str.length; ++ci) {\n        var d = this._appendChar(str[ci], flags, checkTail);\n        if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n        details.aggregate(d);\n      }\n\n      // append tail but aggregate only tailShift\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift;\n        // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n      return details;\n    }\n\n    /** */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n\n    /** Calls function and reapplies current value */\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput;\n      // append lost trailing chars at end\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n      delete this._refreshing;\n      return ret;\n    }\n\n    /** */\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n\n    /** */\n  }, {\n    key: \"doSkipInvalid\",\n    value: function doSkipInvalid(ch) {\n      return this.skipInvalid;\n    }\n\n    /**\n      Prepares string before mask processing\n      @protected\n    */\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n\n    /**\n      Validates if value is acceptable\n      @protected\n    */\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n\n    /**\n      Does additional processing in the end of editing\n      @protected\n    */\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n\n    /** */\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n\n    /** */\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n\n    /** */\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n        input: true\n      };\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var eagerRemove = this.eager === true || this.eager === 'remove';\n      var oldRawValue;\n      if (eagerRemove) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n      var startChangePos = start;\n      var details = new ChangeDetails();\n\n      // if it is just deletion without insertion\n      if (removeDirection !== DIRECTION.NONE) {\n        startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n        // adjust tailShift if start was aligned\n        details.tailShift = startChangePos - start;\n      }\n      details.aggregate(this.remove(startChangePos));\n      if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          var valLength;\n          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n      return details.aggregate(this.append(inserted, flags, tail));\n    }\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return this.mask === mask;\n    }\n  }, {\n    key: \"typedValueEquals\",\n    value: function typedValueEquals(value) {\n      var tval = this.typedValue;\n      return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n    }\n  }]);\n  return Masked;\n}();\nMasked.DEFAULTS = {\n  format: String,\n  parse: function parse(v) {\n    return v;\n  },\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["ChangeDetails","ContinuousTailDetails","isString","normalizePrepare","DIRECTION","forceDirection","IMask","Masked","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","keys","length","withValueRefresh","bind","value","state","resolve","reset","append","input","doCommit","doParse","doFormat","extractInput","raw","isComplete","cursorPos","direction","fromPos","arguments","undefined","toPos","Math","min","slice","tail","String","appendTo","ch","inserted","rawInserted","flags","checkTail","consistentState","details","doPrepare","aggregate","_appendCharRaw","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailShift","tailDetails","appendTail","toString","shift","str","Error","_beforeTailState","ci","d","_appendChar","doSkipInvalid","eager","_appendEager","fn","_refreshing","rawInput","rawInputValue","ret","indexOf","_isolated","skipInvalid","prepare","validate","parent","commit","format","parse","start","deleteCount","removeDirection","tailPos","extractTail","eagerRemove","oldRawValue","startChangePos","NONE","nearestInputPos","remove","FORCE_LEFT","valLength","FORCE_RIGHT","mask","tval","typedValue","EMPTY_VALUES","includes","v","default"],"sources":["C:/Users/admin/Desktop/Документы/123123/GW/Information-System-of-Internet-Provider/SiteReact/gg/app/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\nclass Masked {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */ // $FlowFixMe no ideas\n  /** Transforms value before mask processing */\n  /** Validates if value is acceptable */\n  /** Does additional processing in the end of editing */\n  /** Format typed value to string */\n  /** Parse strgin to get typed value */\n  /** Enable characters overwriting */\n  /** */\n  /** */\n  /** */\n  constructor(opts) {\n    this._value = '';\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n    this.isInitialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    // $FlowFixMe\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /**\n    Sets new options\n    @protected\n  */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n\n  /** */\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value);\n  }\n\n  /** Resolve new value */\n  resolve(value) {\n    this.reset();\n    this.append(value, {\n      input: true\n    }, '');\n    this.doCommit();\n    return this.value;\n  }\n\n  /** */\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.reset();\n    this.append(value, {}, '');\n    this.doCommit();\n  }\n\n  /** */\n  get typedValue() {\n    return this.doParse(this.value);\n  }\n  set typedValue(value) {\n    this.value = this.doFormat(value);\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.reset();\n    this.append(value, {\n      raw: true\n    }, '');\n    this.doCommit();\n  }\n  get displayValue() {\n    return this.value;\n  }\n\n  /** */\n  get isComplete() {\n    return true;\n  }\n\n  /** */\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return Math.min(this.value.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return this.value.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  // $FlowFixMe no ideas\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const consistentState = this.state;\n    let details;\n    [ch, details] = normalizePrepare(this.doPrepare(ch, flags));\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  // $FlowFixMe no ideas\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const details = new ChangeDetails();\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n    return details;\n  }\n\n  /** */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this.isInitialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n\n  /** */\n  runIsolated(fn) {\n    if (this._isolated || !this.isInitialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n\n  /** */\n  doSkipInvalid(ch) {\n    return this.skipInvalid;\n  }\n\n  /**\n    Prepares string before mask processing\n    @protected\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.prepare ? this.prepare(str, this, flags) : str;\n  }\n\n  /**\n    Validates if value is acceptable\n    @protected\n  */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /**\n    Does additional processing in the end of editing\n    @protected\n  */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n\n  /** */\n  doFormat(value) {\n    return this.format ? this.format(value, this) : value;\n  }\n\n  /** */\n  doParse(str) {\n    return this.parse ? this.parse(str, this) : str;\n  }\n\n  /** */\n  splice(start, deleteCount, inserted, removeDirection) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      input: true\n    };\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n  }\n}\nMasked.DEFAULTS = {\n  format: String,\n  parse: v => v,\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}